### SAMPLE TABLE AND DISH FOR OUT-OF-SAMPLE OBSERVATIONS
# THIS HAS BEEN MOVED OUT OF THE LOOP FOR THE MOMENT
}
observationDishAllocation
observationDishAllocation
observationDishAllocation[1:200]   = rep(1,100);
source("~/Library/CloudStorage/Dropbox/gio &/Bocconi/Augusto & Giovanni/HiddenHPYP/R/DPMixture/hhpyp.R", echo=TRUE)
library(salso)
salso(groupRestaurantAllocationAcrossGibbs)
salso(groupRestaurantAllocationAcrossGibbs[-200,])
source("~/Library/CloudStorage/Dropbox/gio &/Bocconi/Augusto & Giovanni/HiddenHPYP/R/DPMixture/hhpyp.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/gio &/Bocconi/Augusto & Giovanni/HiddenHPYP/R/DPMixture/hhpyp.R", echo=TRUE)
# to delete
r=1
indexCustomerGlobal=1
indexGroup=1
nByGroup = c(50, 50, 50, 50, 100)*2
nGibbsUpdates = 1000 # 300
nObs = sum(nByGroup)
nGroups = length(nByGroup)
nTables = nObs # number of occupied tables in the franchise
maxTableIndex = nObs # max table index (nTables+nFreeTables=maxTableIndex)
#nTablesInGroup = nByGroup
# nTablesInRestaurant = nByGroup
observationGroupAllocation = rep(1:nGroups, times = nByGroup)
observationDishAllocation          = integer(nObs)
observationDishAllocation[1:200]   = rep(1,100);
observationDishAllocation[201:400] = rep(c(rep(2,30),rep(3,40),rep(1,30)),2)
observationDishAllocation[401:600] = rep(1:100,2)
observationTableAllocation = 1:nObs
groupRestaurantAllocation  = 1:nGroups
observationRestaurantAllocation = groupRestaurantAllocation[observationGroupAllocation]
nGroupsInRestaurant = as.integer(table(groupRestaurantAllocation)) # rep(1,nRest)
nRest = length(table(groupRestaurantAllocation))
maxRestIndex = nRest
tablesValues = observationDishAllocation
tableRestaurantAllocation = observationRestaurantAllocation
nPeopleAtTable = rep(1,nObs)
dishesCounts = as.vector(table(observationDishAllocation)) # how many people are eating a certain dish
nDishes = length(dishesCounts)
set.seed(123)
for (r in 1:nGibbsUpdates) {
### ALLOCATE IN-SAMPLE OBSERVATIONS TO TABLES
if(r%%20==0){print(r)}
indexCustomerGlobal = 1
for (indexGroup in 1:nGroups) {
indexRestaurant = groupRestaurantAllocation[indexGroup]
##### compute quantities without group J
observationRestaurantAllocation_noJ = observationRestaurantAllocation
individualsInCurrentGroup = firstIndividuals[indexGroup]:lastIndividuals[indexGroup]
observationRestaurantAllocation_noJ[individualsInCurrentGroup] = -1
# nPeopleInRestaurant_noJ = sum(observationRestaurantAllocation_noJ==indexRestaurant)
dishesCountsInGroup = as.vector(table(factor(observationDishAllocation[individualsInCurrentGroup],
levels = 1:nDishes))) # number of people eating dish d in group J
dishesCounts_noJ = dishesCounts - dishesCountsInGroup
nDishes_noJ = nDishes - sum(dishesCounts_noJ==0)
##### end computation of quantities without group J
##### initialize quantities for computation of acceptance probability for the "current" state
# nPeopleInRestaurantCS = nPeopleInRestaurant_noJ
dishesCountsCS = dishesCounts_noJ
nDishesCS = nDishes_noJ
##### end initialization quantities for acceptance prob
# define global index to be used in the MH part to start from the right global index
indexCustomerGlobalMH = indexCustomerGlobal
logP_CS = 0 # log of P[X_ji=x|____S] to be used in MH
for (indexCustomerGroup in 1:nByGroup[indexGroup]) {
currentTable = observationTableAllocation[indexCustomerGlobal] # get the current table
currentDish = observationDishAllocation[indexCustomerGlobal] # get the current dish (this definition could be avoided)
nPeopleAtTable[currentTable] = nPeopleAtTable[currentTable] - 1
if(nPeopleAtTable[currentTable] == 0) { # free the table
nFreeTables = nFreeTables + 1
freeTables = c(currentTable,freeTables)
tableRestaurantAllocation[currentTable] = -1
nTables = nTables - 1
tablesValues[currentTable] = -1
}
nTablesInRestaurant = sum(tableRestaurantAllocation==indexRestaurant)
indecesTablesInRestaurant = (1:maxTableIndex)[tableRestaurantAllocation==indexRestaurant] # indeces of tables in the restaurant
indecesPossibleTables = (tablesValues[indecesTablesInRestaurant] == currentDish) # tables in the restaurant serving the current dish
possibleTables = c(indecesTablesInRestaurant[indecesPossibleTables],-1)
probNewTable = (theta + sigma*nTablesInRestaurant)/(nTables + theta0)
nTablesServingCurrentDish = sum(tablesValues == currentDish)
if(nTablesServingCurrentDish > 0) {
probNewTable = probNewTable*(nTablesServingCurrentDish - sigma0)
}
probs = c(nPeopleAtTable[indecesTablesInRestaurant][indecesPossibleTables] - sigma, probNewTable)
newTableAllocation = sample(possibleTables,1,replace = F, prob = probs)
if(newTableAllocation < 0) {
##### COMPUTE THE CONTRIBUTION PART OF THE LOG ACCEPTANCE PROBABILITY
individualsToRemove = c((firstIndividuals[indexGroup]-1+indexCustomerGroup):lastIndividuals[indexGroup])
nPeopleAtTableCS = as.integer(table(factor(observationTableAllocation[-individualsToRemove], levels = 1:maxTableIndex))) # nPeopleAtTable - as.integer(table(factor(observationTableAllocation[individualsToRemove], levels = 1:maxTableIndex))) # as.integer(table(factor(observationTableAllocation_noJ, levels = 1:maxTableIndex))) # this is wrong since it removes twice the current observation from the count of people at table
nTablesCS = sum(nPeopleAtTableCS>0)
# compute nTablesInRestaurantCS
# freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0]
# tableRestaurantAllocationCS = tableRestaurantAllocation
# tableRestaurantAllocationCS[freeTablesCS] = -1
# nTablesInRestaurantCS = sum(tableRestaurantAllocationCS==indexRestaurant)
# nTablesInRestaurantCS =
#   length(table(observationTableAllocation[-individualsToRemove][observationRestaurantAllocation[-individualsToRemove]==indexRestaurant]))
#
# compute log of P[X_ji=x|____]
if(dishesCountsCS[currentDish] == 0){ # X_ji = "new"
logP_CS = logP_CS +
log(theta0 + nDishesCS*sigma0) -
log(theta0 + nTablesCS)
nDishesCS = nDishesCS + 1
} else{
# compute number of tables serving the current dish in the whole franchise, excluding individualsToRemove
# nTablesServingCurrentDishCS = length(table(observationTableAllocation[-individualsToRemove][observationDishAllocation[-individualsToRemove] == currentDish]))
# alternative computation:
freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0] # which(nPeopleAtTableCS == 0)
tablesValuesCS = tablesValues
tablesValuesCS[freeTablesCS] = -1
nTablesServingCurrentDishCS = sum(tablesValuesCS==currentDish)
# get the tables in current restaurant serving the current dish (excluding future observations)
# freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0] # which(nPeopleAtTableCS == 0)
# tableRestaurantAllocationCS = tableRestaurantAllocation
# tableRestaurantAllocationCS[freeTablesCS] = -1
# tablesInRestaurantServingCurrentDishCS = (1:maxTableIndex)[((tableRestaurantAllocationCS == indexRestaurant)&(tablesValues == currentDish))]
# tablesValuesCS = tablesValues
# tablesValuesCS[freeTablesCS] = -1
#nTablesInRestaurantServingCurrentDishCS = length(tablesInRestaurantServingCurrentDish)
logP_CS = logP_CS +
log(nTablesServingCurrentDishCS - sigma0) -
log(theta0 + nTablesCS)
}
### update quantities of "current state"
# nPeopleInRestaurantCS = nPeopleInRestaurantCS + 1
dishesCountsCS[currentDish] = dishesCountsCS[currentDish] + 1
##### UPDATE GIBBS SAMPLING QUANTITIES
nTables = nTables + 1
if(nFreeTables > 0) { # pick the first free table
newTableAllocation = freeTables[1]
freeTables = freeTables[-1]
nFreeTables = nFreeTables - 1
nPeopleAtTable[newTableAllocation] = 1
tablesValues[newTableAllocation] = currentDish
tableRestaurantAllocation[newTableAllocation] = indexRestaurant # assign table to restaurant
} else { # create a new table
maxTableIndex = maxTableIndex + 1
newTableAllocation = maxTableIndex
nPeopleAtTable = c(nPeopleAtTable,1)
tablesValues = c(tablesValues,currentDish)
tableRestaurantAllocation = c(tableRestaurantAllocation,indexRestaurant) # assign table to restaurant
}
} else{ # the sampled table is already occupied in the restaurant --> just update the relevant quantities
nPeopleAtTable[newTableAllocation] = nPeopleAtTable[newTableAllocation] + 1
}
observationTableAllocation[indexCustomerGlobal] = newTableAllocation
indexCustomerGlobal = indexCustomerGlobal + 1
}
#### MH STEP
# we begin the MH proposal sampling
nRestMH = nRest
maxRestIndexMH = maxRestIndex
groupRestaurantAllocationMH = groupRestaurantAllocation
nGroupsInRestaurantMH = nGroupsInRestaurant
nGroupsInRestaurantMH[indexRestaurant] = nGroupsInRestaurantMH[indexRestaurant] - 1
nFreeRestaurantsMH = nFreeRestaurants
freeRestaurantsMH = freeRestaurants
if(nGroupsInRestaurantMH[indexRestaurant] == 0) {
nRestMH = nRestMH - 1
nFreeRestaurantsMH = nFreeRestaurantsMH + 1
freeRestaurantsMH = c(indexRestaurant,freeRestaurantsMH)
}
#### PROPOSE A NEW RESTAURANT AND TABLE ALLOCATION
#### sample restaurant
nonEmptyRest = (1:maxRestIndexMH)[nGroupsInRestaurantMH>0] # restaurants with at least one group assigned
possibleRestaurants = c(nonEmptyRest,-1)
probs =c(nGroupsInRestaurantMH[nonEmptyRest] - alpha, gamma + alpha*nRestMH)
newRestaurantAllocation = sample(possibleRestaurants,1,replace = F, prob = probs)
if(newRestaurantAllocation < 0) {
nRestMH = nRestMH + 1
if(nFreeRestaurantsMH > 0) { # pick the first free restaurant
newRestaurantAllocation = freeRestaurantsMH[1]
freeRestaurantsMH = freeRestaurantsMH[-1]
nFreeRestaurantsMH = nFreeRestaurantsMH - 1
nGroupsInRestaurantMH[newRestaurantAllocation] = 1
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
} else { # create a new restaurant
maxRestIndexMH = maxRestIndexMH + 1
newRestaurantAllocation = maxRestIndexMH
nGroupsInRestaurantMH = c(nGroupsInRestaurantMH,1)
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
}
} else{ # the sampled restaurants contains already some groups --> just update the relevant quantities
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
nGroupsInRestaurantMH[newRestaurantAllocation] = nGroupsInRestaurantMH[newRestaurantAllocation] + 1
}
#### sample table allocation
# initialize MH quantities excluding current group j
maxTableIndexMH = maxTableIndex
observationTableAllocationMH = observationTableAllocation
observationTableAllocationMH[individualsInCurrentGroup] = -1
observationRestaurantAllocationMH = observationRestaurantAllocation_noJ # computed above
observationDishAllocationMH = observationDishAllocation
observationDishAllocationMH[individualsInCurrentGroup] = -1
nPeopleAtTableMH = as.integer(table(factor(observationTableAllocation[-individualsInCurrentGroup], levels = 1:maxTableIndex))) # nPeopleAtTable - as.integer(table(factor(observationTableAllocation[individualsInCurrentGroup], levels = 1:maxTableIndex))) # as.integer(table(factor(observationTableAllocation_noJ, levels = 1:maxTableIndex)))
nTablesMH = sum(nPeopleAtTableMH>0)
freeTablesMH = (1:maxTableIndexMH)[nPeopleAtTableMH == 0]
nFreeTablesMH = length(freeTablesMH)
tablesValuesMH = tablesValues
tablesValuesMH[freeTablesMH] = -1
tableRestaurantAllocationMH = tableRestaurantAllocation
tableRestaurantAllocationMH[freeTablesMH] = -1
# nPeopleInRestaurantMH = nPeopleInRestaurant_noJ # computed above
dishesCountsMH = dishesCounts_noJ
nDishesMH = nDishes - sum(dishesCountsMH==0)
# # nTablesServingCurrentDish = sum(tablesValues_noJ == observationDishAllocation[indexCustomerGlobal])
##### end computation of quantities without group J
# #### UPDATE TABLE CONFIGURATION IN THE CURRENT GROUP (analogous to the sampling from the full conditionals)
logP_MH = 0 # log of P[X_ji=x|____ S'] to be used in MH
for (indexCustomerGroup in 1:nByGroup[indexGroup]) { # this loop should be joined with the loop for the full conditionals!!!!!
indecesTablesInRestaurant = (1:maxTableIndexMH)[tableRestaurantAllocationMH==newRestaurantAllocation]
currentDish = observationDishAllocation[indexCustomerGlobalMH] # get the current dish
observationRestaurantAllocationMH[indexCustomerGlobalMH] = newRestaurantAllocation
nTablesInRestaurant = sum(tableRestaurantAllocationMH==newRestaurantAllocation)
indecesPossibleTables = (tablesValuesMH[indecesTablesInRestaurant] == observationDishAllocation[indexCustomerGlobalMH])
possibleTables = c(indecesTablesInRestaurant[indecesPossibleTables],-1)
probNewTable = (theta + sigma*nTablesInRestaurant)/(nTablesMH + theta0)
nTablesServingCurrentDishMH = sum(tablesValuesMH == observationDishAllocation[indexCustomerGlobalMH])
if(nTablesServingCurrentDishMH > 0) {
probNewTable = probNewTable*(nTablesServingCurrentDishMH - sigma0)
}
probs = c(nPeopleAtTableMH[indecesTablesInRestaurant][indecesPossibleTables] - sigma, probNewTable)
newTableAllocation = sample(possibleTables,1,replace = F, prob = probs)
if(newTableAllocation < 0) {
# compute log of P[X_ji=x|____S']
if(dishesCountsMH[currentDish] == 0){ # X_ji = "new"
logP_MH = logP_MH +
log(theta0 + nDishesMH*sigma0) -
log(theta0 + nTablesMH)
} else{
# compute number of tables serving the current dish in the whole franchise, excluding future individuals
nTablesServingCurrentDishMH = length(table(observationTableAllocationMH[observationDishAllocationMH == currentDish]))
# get the tables in current restaurant serving the current dish (excluding future observations)
# tablesInRestaurantServingCurrentDish = (1:maxTableIndexMH)[((tableRestaurantAllocationMH == newRestaurantAllocation)&(tablesValuesMH == currentDish))]
logP_MH = logP_MH +
log(nTablesServingCurrentDishMH - sigma0) -
log(theta0 + nTablesMH)
}
### update quantities of MH
# nPeopleInRestaurantMH = nPeopleInRestaurantMH + 1
dishesCountsMH[currentDish] = dishesCountsMH[currentDish] + 1
observationDishAllocationMH[indexCustomerGlobalMH] = currentDish
nTablesMH = nTablesMH + 1
if(nFreeTablesMH > 0) { # pick the first free table
newTableAllocation = freeTablesMH[1]
freeTablesMH = freeTablesMH[-1]
nFreeTablesMH = nFreeTablesMH - 1
nPeopleAtTableMH[newTableAllocation] = 1
tablesValuesMH[newTableAllocation] = observationDishAllocationMH[indexCustomerGlobalMH]
tableRestaurantAllocationMH[newTableAllocation] = newRestaurantAllocation # assign table to restaurant
} else { # create a new table
maxTableIndexMH = maxTableIndexMH + 1
newTableAllocationMH = maxTableIndexMH
nPeopleAtTableMH = c(nPeopleAtTableMH,1)
tablesValuesMH = c(tablesValuesMH,observationDishAllocationMH[indexCustomerGlobalMH])
tableRestaurantAllocationMH = c(tableRestaurantAllocationMH,newRestaurantAllocation) # assign table to restaurant
}
} else{ # the sampled table is already occupied in the restaurant --> just update the relevant quantities
nPeopleAtTableMH[newTableAllocation] = nPeopleAtTableMH[newTableAllocation] + 1
}
observationTableAllocationMH[indexCustomerGlobalMH] = newTableAllocation
# update indexCustomerGlobalMH
indexCustomerGlobalMH = indexCustomerGlobalMH + 1
}
pAccept = min(exp(logP_MH - logP_CS),1)
accept = runif(1) < pAccept
# print(pAccept)
if(accept == T){
nRest = nRestMH
maxRestIndex = maxRestIndexMH
groupRestaurantAllocation[indexGroup] = groupRestaurantAllocationMH[indexGroup]
nGroupsInRestaurant = nGroupsInRestaurantMH
nFreeRestaurants = nFreeRestaurantsMH
freeRestaurants = freeRestaurantsMH
maxTableIndex = maxTableIndexMH
observationTableAllocation = observationTableAllocationMH
observationRestaurantAllocation = observationRestaurantAllocationMH
nPeopleAtTable = nPeopleAtTableMH
nTables = nTablesMH
freeTables = freeTablesMH
nFreeTables = nFreeTablesMH
tablesValues = tablesValuesMH
tableRestaurantAllocation = tableRestaurantAllocationMH
}
##### END OF METROPOLIS HASTINGS STEP
### EDIT THIS PART TO UPDATE THE TABLES ALLOCATIONS FOR THE WHOLE GROUP
groupRestaurantAllocationAcrossGibbs[r, indexGroup] = groupRestaurantAllocation[indexGroup]
observationTableAllocationAcrossGibbs[r,firstIndividuals[indexGroup]:lastIndividuals[indexGroup]] =
observationTableAllocation[firstIndividuals[indexGroup]:lastIndividuals[indexGroup]]
}
### SAMPLE TABLE AND DISH FOR OUT-OF-SAMPLE OBSERVATIONS
# THIS HAS BEEN MOVED OUT OF THE LOOP FOR THE MOMENT
}
nTablesServingCurrentDish
sigma0
log(nTablesServingCurrentDishCS - sigma0)
nTablesServingCurrentDishCS
cite(splines)
library(bs)
library(splines)
cite(splines)
quote(spline())
quote(spline)
citation(spline)
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.15
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(splines)
library(ggplot2)
theme_set(theme_bw(base_size = 14))
x <- seq(0, 1, by=0.001)
spl <- bs(x,df=6)
plot(spl[,1]~x, ylim=c(0,max(spl)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
for (j in 2:ncol(spl)) lines(spl[,j]~x, lwd=2, col=j)
x <- seq(0, 1, by=0.001)
spl <- bs(x,degree=3)
plot(spl[,1]~x, ylim=c(0,max(spl)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
for (j in 2:ncol(spl)) lines(spl[,j]~x, lwd=2, col=j)
spl <- bs(x,degree=3,knots=seq(0, 1, by=0.1))
plot(spl[,1]~x, ylim=c(0,max(spl)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
for (j in 2:ncol(spl)) lines(spl[,j]~x, lwd=2, col=j)
spl
x            <- seq(0, 1, by=0.001)
spline_basis <- bs(x,degree=3,knots=seq(0, 1, by=0.1))
x            <- seq(0, 1, by=0.001)
spline_basis <- bs(x,degree=3,knots=seq(0, 1, by=0.1))
# Simple plot in R
plot(spline_basis[,1]~x, ylim=c(0,max(spl)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
for (j in 2:ncol(spl)){
lines(spline_basis[,j]~x, lwd=2, col=j)
}
x            <- seq(0, 1, by=0.001)
spline_basis <- bs(x,degree=3,knots=seq(0, 1, by=0.2))
# Simple plot in R
plot(spline_basis[,1]~x, ylim=c(0,max(spl)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
for (j in 2:ncol(spl)){
lines(spline_basis[,j]~x, lwd=2, col=j)
}
interp.df <- data.frame(x=x, spline_basis) %>%
melt(id.vars="x", variable.name="Spline", value.name="y")
ggplot(interp.df) +
aes(x=x, y=y, color=Spline, group=Spline) +
geom_line() +
geom_point(data=knot.df) +
scale_color_discrete(guide=FALSE)
interp.df
interp.df <- data.frame(x=x, spline_basis) %>%
melt(id.vars="x", variable.name="Spline", value.name="y")
library(reshape2)
# Plot in R with ggplot2
str(spline_basis)
plot_df <- data.frame(x=x, t(spline_basis))
x
x            <- seq(0, 1, by=0.001)
str(spline_basis)
plot_df <- data.frame(x=x, spline_basis)
str(plot_df)
plot_df <- data.frame(x=x, spline_basis) %>%
melt(id.vars="x", variable.name="Spline", value.name="y")
ggplot(interp.df) +
aes(x=x, y=y, color=Spline, group=Spline) +
geom_line() +
geom_point(data=knot.df) +
scale_color_discrete(guide=FALSE)
ggplot(plot_df) +
aes(x=x, y=y, color=Spline, group=Spline) +
geom_line() +
geom_point(data=knot.df) +
scale_color_discrete(guide=FALSE)
plot_df <- data.frame(x=x, spline_basis) %>%
melt(id.vars="x", variable.name="Spline", value.name="y")
plot_df
plot_df <- data.frame(x=x, spline_basis)
plot_df <- data.frame(x=x, spline_basis) %>%
melt(id.vars="x")
plot_df
plot_df <- data.frame(x=x, spline_basis)
plot_df
data.frame(x=x, spline_basis) %>%
melt(id.vars="x", variable.name="Spline", value.name="y")
data.frame(x=x, spline_basis) %>%
melt(id.vars="x", variable.name="Spline", value.name="y")
data.frame(x=x, spline_basis) %>%
melt(id.vars="x", variable.name="Spline", value.name="y")
# Plot B-splines
# Codes accompanying "Separate Exchangeability as
# Modeling Principle in Bayesian Nonparametrics"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.15
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(splines)
library(ggplot2)
library(reshape2)
theme_set(theme_bw(base_size = 14))
x            <- seq(0, 1, by=0.001)
spline_basis <- bs(x,degree=3,knots=seq(0, 1, by=0.2))
data.frame(x=x, spline_basis) %>%
melt(id.vars="x", variable.name="Spline", value.name="y")
plot_df <- melt(data.frame(x=x, spline_basis), id.vars="x",
variable.name="Spline", value.name="y")
plot_df
ggplot(plot_df) +
aes(x=x, y=y, color=basis, group=basis) +
geom_line() +
geom_point(data=knot.df) +
scale_color_discrete(guide=FALSE)
ggplot(plot_df) +
aes(x=x, y=y, color=basis, group=basis) +
geom_line() +
scale_color_discrete(guide=FALSE)
# Plot in R with ggplot2
plot_df <- melt(data.frame(x=x, spline_basis), id.vars="x",
variable.name="basis", value.name="y")
ggplot(plot_df) +
aes(x=x, y=y, color=basis, group=basis) +
geom_line() +
scale_color_discrete(guide=FALSE)
library(latex2exp)
spline_basis
ggplot(plot_df) +
aes(x=x, y=y, color=basis, group=basis) +
geom_line() + ylab(latex2exp::TeX("$B_{i,4}(x)$")) +
scale_color_discrete(guide=FALSE)
seq(0, 1, by=0.2)
# Plot B-splines
# Codes accompanying "Separate Exchangeability as
# Modeling Principle in Bayesian Nonparametrics"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.15
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(splines)
library(ggplot2)
library(latex2exp)
library(reshape2)
theme_set(theme_bw(base_size = 14))
x            <- seq(0, 1, by=0.001)
knots_seq    <- seq(0, 1, by=0.2)
oreder_spl   <- 4
spline_basis <- bs(x, degree=oreder_spl-1, knots=knots_seq)
# Simple plot in R
plot(spline_basis[,1]~x, ylim=c(0,max(spl)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.15
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(splines)
library(ggplot2)
library(latex2exp)
library(reshape2)
theme_set(theme_bw(base_size = 14))
x            <- seq(0, 1, by=0.001)
knots_seq    <- seq(0, 1, by=0.2)
oreder_spl   <- 4
spline_basis <- bs(x, degree=oreder_spl-1, knots=knots_seq)
# Simple plot in R
plot(spline_basis[,1]~x, ylim=c(0,max(spl)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
# Simple plot in R
plot(spline_basis[,1]~x, ylim=c(0,max(spline_basis)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
for (j in 2:ncol(spl)){
lines(spline_basis[,j]~x, lwd=2, col=j)
}
# Simple plot in R
plot(spline_basis[,1]~x, ylim=c(0,max(spline_basis)), type='l', lwd=2, col=1,
xlab="Cubic B-spline basis", ylab="")
for (j in 2:ncol(spline_basis)){
lines(spline_basis[,j]~x, lwd=2, col=j)
}
# Plot in R with ggplot2
plot_df <- melt(data.frame(x=x, spline_basis), id.vars="x",
variable.name="basis", value.name="y")
ggplot(plot_df) +
aes(x=x, y=y, color=basis, group=basis) +
geom_line() + ylab(latex2exp::TeX("$B_{i,4}(x)$")) +
scale_color_discrete(guide=FALSE)
# We have the following number of cubic splines
length(knots_seq) + 2
P = ggplot(plot_df) +
aes(x=x, y=y, color=basis, group=basis) +
geom_line() + ylab(latex2exp::TeX("$B_{i,4}(x)$")) +
scale_color_discrete(guide=FALSE)
if(FALSE){
} else{
P
}
ggsave(plot=P, file ="Image/Basis_Spline.pdf",
width=20, height=12, units = 'cm')
length(knots_seq)
ggsave(plot=P, file ="Image/Basis_Spline.pdf",
width=20, height=10, units = 'cm')
plt_reg_ggplot
