sqrt(sum(coef(ridge.mod)[-1,50])^2)
sqrt(sum(coef(ridge.mod)[-1,100])^2)
ridge.mod$lambda[100]
predict(ridge.mod, s=50, type="coefficient")[1:20,]
set.seed(1)
cv.out <- cv.glmnet(x, y, alpha=0)
plot(cv.out)
set.seed(1)
train <- sample(1:nrow(x), nrow/2)
train <- sample(1:nrow(x), nrow(x)/2)
train
test <- (-train)
test
train
y.test <- y[test]
y.test
ridge.mod <- glmnet(x[train,], y[train], alpha=0, lambda = grid, thresh=1e-12)
ridge.mod <- predict(ridge.mod, s=4, newx = x[test,])
ridge.mod <- glmnet(x[train,], y[train], alpha=0, lambda = grid, thresh=1e-12)
ridge.pred <- predict(ridge.mod, s=4, newx = x[test,])
ridge.pred
mean((ridge.pred-y.test)^2)
cv.out <- cv.glmnet(x[train,], y[train], alpha=0)
plot(cv.out)
bestlam <- cv.out$lambda.min
cv.out$lambda.min
bestlam <- cv.out$lambda.min
ridge.pred <- predict(ridge.mod, s=bestlam, newx = x[test,])
mean((ridge.pred-y.test)^2)
# Lasso
lasso.mod <- glmnet(x[train,], y[train], alpha=1, lambda = grid)
plot(lasso.mod)
plot(lasso.mod, xvar="lambda")
set.seed(1)
cv.out <- cv.glmnet(x[train,], y[train], alpha=1)
plot(cv.out)
bestlam <- cv.out$lambda.min
lasso.pred <- predict(lasso.mod, s=bestlam, newx=x[test,])
mean((lasso.pred-y.test)^2)
mean((ridge.pred-y.test)^2)
ridge.mod <- glmnet(x[train,], y[train], alpha=0, lambda = grid, thresh=1e-12)
cv.out <- cv.glmnet(x[train,], y[train], alpha=0)
bestlam <- cv.out$lambda.min
ridge.pred <- predict(ridge.mod, s=bestlam, newx = x[test,])
mean((ridge.pred-y.test)^2)
mean((lasso.pred-y.test)^2)
mean((ridge.pred-y.test)^2)
# PCR
library(pls)
set.seed(2)
pcr.fit <- pcr(Salary~., data=Hitters, scale=TRUE, validationplot="CV")
summary(pcr.fit)
validationplot(pcr.fit, val.type="MSEP")
set.seed(1)
pls.fit <- plsr(Salary~., data=Hitters, subset=train, scale=T, validation="CV")
summary(pls.fit)
validationplot(pls.fit, val.type = "MSEP")
library(updateR)
updateR()
2+2
library(ISLR2)
attach(Wage)
fit <- lm(wage ~ poly(age, 4), data=Wage)
coef(summary(fit))
fit2 <- lm(wage ~ poly(age, 4, raw=T), data=Wage)
coef(summary(fit2))
fit2a <- lm(wage ~ age + I(age^2) + I(age^3) + I(age^4), data=Wage)
coef(summary(fit2a))
agelims <- range(age)
age.grid <- seq(from=agelims[1], to=agelims[2])
preds <- predict(fit, newdata = list(age=age.grid), se=T)
se.bands <- cbind(preds$fit + 2*preds$se.fit,  preds$fit - 2*preds$se.fit)
plot(age, wage, xlim=agelims, cex=.5, col="darkgrey")
lines(age.grid, preds$fit, lwd=2, col="blue")
matlines(age.grid, se.bands, lwd=1, col="blue", lty=3)
preds2 <- predict(fit2, newdata=list(age=age.grid), se=T)
plot(preds$fit, preds2$fit)
fit.1 <- lm(wage ~ age, data=Wage)
fit.2 <- lm(wage ~ poly(age,2), data=Wage)
fit.1 <- lm(wage ~ age, data=Wage)
fit.2 <- lm(wage ~ poly(age,2), data=Wage)
fit.3 <- lm(wage ~ poly(age,3), data=Wage)
fit.4 <- lm(wage ~ poly(age,4), data=Wage)
fit.5 <- lm(wage ~ poly(age,5), data=Wage)
anova(fit.1, fit.2, fit.3, fit.4, fit.5)
fit <- glm(I(wage > 250) ~ poly(age, 4), data=Wage, family = binomial)
preds <-  predict(fit, newdata=list(age=age.grid), se=T)
preds
exp(preds$fit)/(1 + exp(preds$fit))
pfit <- exp(preds$fit)/(1 + exp(preds$fit))
pfit
se.bands.logit <- cbind(preds$fit + 2 *preds$se.fit, preds$fit - 2 * preds$se.fit)
se.bands <-  exp(se.bands.logit)/(1 + exp(se.bands.logit))
plot(age, I(wage > 250), xlim=agelims, type="n", ylim=c(0, 0.2))
points(jitter(age), I(wage > 250)/5, cex=.5, pch="|", col="darkgrey")
lines(age.grid, pfit, lwd=2, col="blue")
matlines(age.grid, se.bands, lwd=1, col="blue", lty=3)
fit <- lm(wage ~ cut(age,4), data=Wage)
table(cut(age,4))
coef(fit)
library(splines)
fit <-lm(wage~ bs(age, knots=c(25,40,60)), data=Wage)
pred <- predict(fit, newdata=list(age=age.grid), se=T)
plot(age, wage, col="grey")
lines(age.grid, pred$fit, lwd=2, col="blue")
lines(age.grid, pred$fit + 2 * pred$se , col="blue", lty="dashed")
lines(age.grid, pred$fit - 2 * pred$se , col="blue", lty="dashed")
bs(age, df=6, "knots")
attr(bs(age, df=6), "knots")
fit2 <- lm(wage~ns(age, df=4),)
fit2 <- lm(wage~ns(age, df=4),data=Wage)
pred2 <- predict(fit2, newdata = list(age=age.grid), se=T)
plot(age, wage, col="grey")
lines(age.grid, pred$fit2, lwd=2, col="blue")
fit2 <- lm(wage~ns(age, df=4),data=Wage)
pred2 <- predict(fit2, newdata = list(age=age.grid), se=T)
plot(age, wage, col="grey")
lines(age.grid, pred2$fit2, lwd=2, col="blue")
lines(age.grid, pred2$fit, lwd=2, col="blue")
fit2 <- lm(wage~ns(age, df=4),data=Wage)
pred2 <- predict(fit2, newdata = list(age=age.grid), se=T)
plot(age, wage, col="grey")
lines(age.grid, pred2$fit, lwd=2, col="blue")
plot(age, wage, col="grey")
lines(age.grid, pred$fit, lwd=2, col="blue")
fit <- smooth.spline(age, wage, df=16)
fit2 <- smooth.spline(age, wage, cv=T)
plot(age, wage, xlim=agelims, cex=.5, col="darkgrey")
lines(fit, col="red", lwd=2)
lines(fit2, col="blue", lwd=2)
legend("topright", legend("16 DF", "6.8 DF"), col=c("red", "blue"), lty=1, lwd=2, cex=.8)
legend("topright", legend("16 DF", "6.8 DF"), col=c("red", "blue"), lty=1, lwd=2, cex=.8)
legend("topright", legend=c("16 DF", "6.8 DF"), col=c("red", "blue"),
lty=1, lwd=2, cex=.8)
gam1 <- lm(wage ~ ns(year, 4) + ns(age,5) + education, data=Wage)
library(gam)
gam2 <- gam(wage ~ s(year,4) + s(age, 5) +education, data=Wage)
par(mfrow=c(1,3))
plot(gam2, se=T, col="blue")
rm(list=ls())
set.seed(135)
# dir <- "~/pap/21/giovanni-exch/prot/R/" # just for P
# setwd(dir)
# source("~/s/first.s")
library(rstudioapi) # version 0.15
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(dplyr)
library(tidyr)
library(mvtnorm)
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.15
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(dplyr)
library(tidyr)
library(mvtnorm)
library(invgamma)
library(splines)
library(ggplot2)
theme_set(theme_bw(base_size = 14))
library(reshape2)
set.seed(135)
source("SEP_fcts.R")
## global variables for the dta
out = readDta_reg("Data-and-Results/data_protein.RData") ## make global vars for the data
X = out$X
y = out$y
## data corrected for patient and/or prot effects (used in MCMC)
yXi  = 0   ## y - (pat effects) (used to update eta)
yEta = 0   ## y - (prot effs) (to update xi)
yEtaXi = 0 ## y - (pat & prot effects) (used to update sigs;
###                          and to evaluate loglik)
my = mean(y,na.rm=T)
sy =  mean(apply(y,2,var,na.rm=T))
ages = out$ages ## age grid (for plotting)
C=out$C ## n columns = n proteins
R=out$R ## n rows = n patients
p=out$p ## dim of design vector for protein effect regression
## for debugging
logl <- 0   # will keep track of log likelihood
oldlogl  <- 0
## prior pars
prior = list(
## column effects (proteins)
meta = rep(0,p),
Seta = diag(p),  ## might want to reduce var of trt offsets (2nd part)
aeta = 1,        ## eta[j] ~ G_eta; G_eta ~ PY(aeta, beta, N(meta,Seta))
beta = 0.05,
## row effects (patients)
mxi = my,       ## xi[i] ~ G_xi; G_xi ~ PY(axi, bxi, N(mxi,Sxi))
Sxi = 1,
axi = 1,
bxi = 0.05,
## hyperpars theta=sig2
asig = 1,
bsig = 5) ## w=1/sigs ~ Ga(asig/2, bsig/2); E(w) = m=a/b, V(w)=m/(b/2)
# Run MCMC
if (F){
startTime = Sys.time()
main_reg(2000)
timeREG = difftime(Sys.time(), startTime, units=("secs"))[[1]]
}
pltInit_reg()
# load("Data-and-Results/yt.RData")
of = maxDiff_reg()
P1 = plt_reg_ggplot(T,T,F,1,case=T,ctr=T)
P2 = plt_reg_ggplot(T,T,F,1001,case=T,ctr=T)
library(cowplot)
P1 = P1 + theme(axis.title = element_blank())
P2 = P2 + theme(axis.title = element_blank())
P  = plot_grid(P1, P2)
# Individual plot
P  = P +
draw_label("ages", x= 0.52, y=  0, vjust=-0.5, angle= 0) +
draw_label("Y",    x=  0, y=0.55, vjust= 1.5, angle=90)
P
######### Normal- QQtest #####################
chain = mcmc[,-1]
colnames(chain) = c("it", "SSM", "sig2", "K-prot", "K-pat", paste("nk",1:5,sep=""), paste("nk",1:5,sep=""))
# Check
table(chain$`K-pat`)
table(chain$`K-prot`)
plt_reg(F,T,F,of[1:20],case=T,ctr=T,dtatype="l")
plt_reg_ggplot(F,T,F,of[1:20],case=T,ctr=T,dtatype="l")
summary(chain$`sig2`)
df <- data.frame(y = as.vector(yt)/mean(sqrt(chain$`sig2`)))
P <- ggplot( df, aes(sample = y))
P <- P + stat_qq() + stat_qq_line()
P
P
ggsave(plot=P, file ="Image/qq_prot.pdf", width=12, height=12, units = 'cm')
sProt <- read.csv("./Data-and-Results/sProt.txt", header=FALSE)
# Leggi senza virgole
colnames(sProt) = c("prot","cl")
sProt[,"prot"]  = factor(sProt[,"prot"])
Clust_prot_mat = matrix(NA, nrow=nrow(sProt)/C, ncol=C)
colnames(Clust_prot_mat) = levels(sProt[,"prot"])
for (lev in levels(sProt[,"prot"])){
Clust_prot_mat[,lev] = sProt[sProt[,"prot"]==lev,"cl"]
}
library(salso)
library(reshape2)
library(scales)
library(plyr)          # version 1.8.8
# Compute probability of co-clustering of prot
dissimlar = psm(Clust_prot_mat)
VI_prot   = salso::salso(Clust_prot_mat,   loss=VI(), nCores = 4,
maxNClusters = 21,
maxZealousAttempts = 100)
table(VI_prot)
dissimlar_ord_prot = reorder_dismat(dissimlar,VI_prot)
library(Cairo)
CairoPNG(filename ='Image/coclust_prot.png', width = 500, height = 500)
# Posterior probabilities of co-clustering of prot
heatmap(dissimlar_ord_prot, Rowv = NA, Colv = NA, scale='none',
labRow = FALSE, labCol = FALSE,
main="proteins prob coclust")
invisible(dev.off())
sPat <- read.csv("./Data-and-Results/sPat.txt", header=FALSE)
# Leggi senza virgole
colnames(sPat) = c("pat","cl")
sPat[,"pat"]  = factor(sPat[,"pat"])
Clust_pat_mat = matrix(NA, nrow=nrow(sPat)/R, ncol=R)
colnames(Clust_pat_mat) = levels(sPat[,"pat"])
for (lev in levels(sPat[,"pat"])){
Clust_pat_mat[,lev] = sPat[sPat[,"pat"]==lev,"cl"]
}
# Compute probability of co-clustering of pat
dissimlar = psm(Clust_pat_mat)
VI_pat    = salso::salso(Clust_pat_mat,   loss=VI(), nCores = 4,
maxNClusters = 21,
maxZealousAttempts = 100)
table(VI_pat)
dissimlar_ord_pat  = reorder_dismat(dissimlar, VI_pat)
CairoPNG(filename ='Image/coclust_pat.png', width = 500, height = 500)
# Posterior probabilities of co-clustering of pat
heatmap(dissimlar_ord_pat, Rowv = NA, Colv = NA, scale='none',
labRow = FALSE, labCol = FALSE,
main="pat prob coclust")
invisible(dev.off())
# Posterior probabilities of co-clustering of pat
heatmap(dissimlar_ord_pat, Rowv = NA, Colv = NA, scale='none',
labRow = FALSE, labCol = FALSE,
main="pat prob coclust")
paper = function()
{ # calls all the plots for the paper
pltLogl = function()
{ # plots trajectory of log likelihood
ll = mcmc[,3]  ## make sure logl is saved in 3rd column! Just check col labels
it = mcmc[,1]
q = quantile(ll, probs=c(0.01,0.999))
plot(it, ll, type="l", xlab="ITERATION", ylab="LOG LIK", bty="l",ylim=q)
}
## to be called after     mdpOffset(mdpEta)
of=maxDiff()
psc.pdf = T
ps("logl")
devoff()
ps("K-pat")
pltK_reg(1)
devoff()
ps("K-pat-traj")
pltK(1,T)
devoff()
ps("K-prot")
pltK(2,T)
devoff()
pltK(2)
ps("201") # for some randomly selected patients
plt(T,T,F,201,case=T,ctr=T)
devoff()
ps("1201")
plt(T,T,F,1201,case=T,ctr=T)
devoff()
ps("2201")
plt(T,T,F,2201,case=T,ctr=T)
devoff()
ps("15")
plt(T,T,F,15,case=T,ctr=T)
devoff()
ps("115")
plt(T,T,F,115,case=T,ctr=T)
devoff()
ps("protP") # plot some proteins, w/o patient effects
plt(F,F,T,of[1:200],case=T,ctr=T,pltm=F)
devoff()
ps("dta")
plt(F,T,F,of[1:20],case=T,ctr=T,dtatype="l")
devoff()
}
####
pltLogl_reg()
####
pltLogl_reg_ggplot = function()
{ # plots trajectory of log likelihood
ll = mcmc[,3]  ## make sure logl is saved in 3rd column! Just check col labels
it = mcmc[,1]
q = quantile(ll, probs=c(0.01,0.999))
plot(it, ll, type="l", xlab="ITERATION", ylab="LOG LIK", bty="l",ylim=q)
paper = function()
{ # calls all the plots for the paper
}
## to be called after     mdpOffset(mdpEta)
of=maxDiff()
psc.pdf = T
ps("logl")
devoff()
ps("K-pat")
pltK_reg(1)
devoff()
ps("K-pat-traj")
pltK(1,T)
devoff()
ps("K-prot")
pltK(2,T)
devoff()
pltK(2)
ps("201") # for some randomly selected patients
plt(T,T,F,201,case=T,ctr=T)
devoff()
ps("1201")
plt(T,T,F,1201,case=T,ctr=T)
devoff()
ps("2201")
plt(T,T,F,2201,case=T,ctr=T)
devoff()
ps("15")
plt(T,T,F,15,case=T,ctr=T)
devoff()
ps("115")
plt(T,T,F,115,case=T,ctr=T)
devoff()
ps("protP") # plot some proteins, w/o patient effects
plt(F,F,T,of[1:200],case=T,ctr=T,pltm=F)
devoff()
ps("dta")
plt(F,T,F,of[1:20],case=T,ctr=T,dtatype="l")
devoff()
}
####
pltLogl_reg_ggplot = function()
{ # plots trajectory of log likelihood
ll = mcmc[,3]  ## make sure logl is saved in 3rd column! Just check col labels
it = mcmc[,1]
q = quantile(ll, probs=c(0.01,0.999))
plot(it, ll, type="l", xlab="ITERATION", ylab="LOG LIK", bty="l",ylim=q)
}
ggplot(it, ll, type="l", xlab="ITERATION", ylab="LOG LIK", bty="l",ylim=q)
data_ll = data.frame(cbind(it, ll))
ll = mcmc[,3]
ll = mcmc[,3]
it = mcmc[,1]
P = ggplot(data=data_ll, aes(x=X1, y=X2)) +
geom_line()+xlab("iter")+ylab("log lik")
# Plot log likelihood
ll = mcmc[,3]
it = mcmc[,1]
P = ggplot(data=data_ll, aes(x=X1, y=X2)) +
geom_line()+xlab("iter")+ylab("log lik")
data_ll = data.frame(cbind(it, ll_out))
# Plot log likelihood
ll_out = mcmc[,3]
it = mcmc[,1]
data_ll = data.frame(cbind(it, ll_out))
P = ggplot(data=data_ll, aes(x=X1, y=X2)) +
geom_line()+xlab("iter")+ylab("log lik")
ggsave(plot=P, file="Image/ll_reg.pdf", height = 3, width = 6)
P
data_ll
P = ggplot(data=data_ll, aes(x=it, y=ll_out)) +
geom_line()+xlab("iter")+ylab("log lik")
P
ggsave(plot=P, file="Image/ll_reg.pdf", height = 3, width = 6)
pltK_reg(1)
pltK(1,T)
pltK_reg(1,T)
source("~/Library/CloudStorage/Dropbox/GitHub/SE-BNP/SEP_Reg.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/SE-BNP/SEP_Reg.R", echo=TRUE)
warnings()
# Individual plot
P  = P +
draw_label("ages", x= 0.52, y=  0, vjust=-0.5, angle= 0) +
draw_label("Y",    x=  0, y=0.55, vjust= 1.5, angle=90)
P
ggsave(plot=P, file ="Image/Ind_prot.pdf", width=20, height=8, units = 'cm')
source("~/Library/CloudStorage/Dropbox/GitHub/SE-BNP/SEP_Reg.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/GitHub/SE-BNP/SEP_Reg.R", echo=TRUE)
pltInit_reg()
# load("Data-and-Results/yt.RData")
of = maxDiff_reg()
P1 = plt_reg_ggplot(T,T,F,1,case=T,ctr=T)
P2 = plt_reg_ggplot(T,T,F,1001,case=T,ctr=T)
library(cowplot)
P1 = P1 + theme(axis.title = element_blank())
P2 = P2 + theme(axis.title = element_blank())
P  = plot_grid(P1, P2)
P
# Individual plot
P  = P +
draw_label("ages", x= 0.52, y=  0, vjust=-0.5, angle= 0) +
draw_label("Y",    x=  0, y=0.55, vjust= 1.5, angle=90)
P
##############################
chain = mcmc[,-1]
colnames(chain) = c("it", "SSM", "sig2", "K-prot", "K-pat", paste("nk",1:5,sep=""), paste("nk",1:5,sep=""))
# Check
table(chain$`K-pat`)
table(chain$`K-prot`)
plt_reg(F,T,F,of[1:20],case=T,ctr=T,dtatype="l")
plt_reg_ggplot(F,T,F,of[1:20],case=T,ctr=T,dtatype="l")
summary(chain$`sig2`)
df <- data.frame(y = as.vector(yt)/mean(sqrt(chain$`sig2`)))
P <- ggplot( df, aes(sample = y))
P <- P + stat_qq() + stat_qq_line()
sProt <- read.csv("./Data-and-Results/sProt.txt", header=FALSE)
# Leggi senza virgole
colnames(sProt) = c("prot","cl")
sProt[,"prot"]  = factor(sProt[,"prot"])
Clust_prot_mat = matrix(NA, nrow=nrow(sProt)/C, ncol=C)
colnames(Clust_prot_mat) = levels(sProt[,"prot"])
for (lev in levels(sProt[,"prot"])){
Clust_prot_mat[,lev] = sProt[sProt[,"prot"]==lev,"cl"]
}
library(salso)
library(reshape2)
library(scales)
library(plyr)          # version 1.8.8
# Compute probability of co-clustering of prot
dissimlar = psm(Clust_prot_mat)
VI_prot   = salso::salso(Clust_prot_mat,   loss=VI(), nCores = 4,
maxNClusters = 21,
maxZealousAttempts = 100)
table(VI_prot)
dissimlar_ord_prot = reorder_dismat(dissimlar,VI_prot)
library(Cairo)
CairoPNG(filename ='Image/coclust_prot.png', width = 500, height = 500)
# Posterior probabilities of co-clustering of prot
heatmap(dissimlar_ord_prot, Rowv = NA, Colv = NA, scale='none',
labRow = FALSE, labCol = FALSE,
main="proteins prob coclust")
invisible(dev.off())
sPat <- read.csv("./Data-and-Results/sPat.txt", header=FALSE)
# Leggi senza virgole
colnames(sPat) = c("pat","cl")
sPat[,"pat"]  = factor(sPat[,"pat"])
Clust_pat_mat = matrix(NA, nrow=nrow(sPat)/R, ncol=R)
colnames(Clust_pat_mat) = levels(sPat[,"pat"])
for (lev in levels(sPat[,"pat"])){
Clust_pat_mat[,lev] = sPat[sPat[,"pat"]==lev,"cl"]
}
# Compute probability of co-clustering of pat
dissimlar = psm(Clust_pat_mat)
VI_pat    = salso::salso(Clust_pat_mat,   loss=VI(), nCores = 4,
maxNClusters = 21,
maxZealousAttempts = 100)
table(VI_pat)
dissimlar_ord_pat  = reorder_dismat(dissimlar, VI_pat)
CairoPNG(filename ='Image/coclust_pat.png', width = 500, height = 500)
# Posterior probabilities of co-clustering of pat
heatmap(dissimlar_ord_pat, Rowv = NA, Colv = NA, scale='none',
labRow = FALSE, labCol = FALSE,
main="pat prob coclust")
invisible(dev.off())
# Plot log likelihood
ll_out = mcmc[,3]
it = mcmc[,1]
data_ll = data.frame(cbind(it, ll_out))
P = ggplot(data=data_ll, aes(x=it, y=ll_out)) +
geom_line()+xlab("iter")+ylab("log lik")
ggsave(plot=P, file="Image/ll_reg.pdf", height = 3, width = 6)
