maxRestIndex = maxRestIndexMH
groupRestaurantAllocation[indexGroup] = groupRestaurantAllocationMH[indexGroup]
nGroupsInRestaurant = nGroupsInRestaurantMH
nFreeRestaurants = nFreeRestaurantsMH
freeRestaurants = freeRestaurantsMH
maxTableIndex = maxTableIndexMH
observationTableAllocation = observationTableAllocationMH
observationRestaurantAllocation = observationRestaurantAllocationMH
nPeopleAtTable = nPeopleAtTableMH
nTables = nTablesMH
freeTables = freeTablesMH
nFreeTables = nFreeTablesMH
tablesValues = tablesValuesMH
tableRestaurantAllocation = tableRestaurantAllocationMH
}
##### END OF METROPOLIS HASTINGS STEP
### EDIT THIS PART TO UPDATE THE TABLES ALLOCATIONS FOR THE WHOLE GROUP
groupRestaurantAllocationAcrossGibbs[r, indexGroup] = groupRestaurantAllocation[indexGroup]
observationTableAllocationAcrossGibbs[r,firstIndividuals[indexGroup]:lastIndividuals[indexGroup]] =
observationTableAllocation[firstIndividuals[indexGroup]:lastIndividuals[indexGroup]]
}
### SAMPLE TABLE AND DISH FOR OUT-OF-SAMPLE OBSERVATIONS
# THIS HAS BEEN MOVED OUT OF THE LOOP FOR THE MOMENT
}
observationDishAllocation
observationDishAllocation
observationDishAllocation[1:200]   = rep(1,100);
source("~/Library/CloudStorage/Dropbox/gio &/Bocconi/Augusto & Giovanni/HiddenHPYP/R/DPMixture/hhpyp.R", echo=TRUE)
library(salso)
salso(groupRestaurantAllocationAcrossGibbs)
salso(groupRestaurantAllocationAcrossGibbs[-200,])
source("~/Library/CloudStorage/Dropbox/gio &/Bocconi/Augusto & Giovanni/HiddenHPYP/R/DPMixture/hhpyp.R", echo=TRUE)
source("~/Library/CloudStorage/Dropbox/gio &/Bocconi/Augusto & Giovanni/HiddenHPYP/R/DPMixture/hhpyp.R", echo=TRUE)
# to delete
r=1
indexCustomerGlobal=1
indexGroup=1
nByGroup = c(50, 50, 50, 50, 100)*2
nGibbsUpdates = 1000 # 300
nObs = sum(nByGroup)
nGroups = length(nByGroup)
nTables = nObs # number of occupied tables in the franchise
maxTableIndex = nObs # max table index (nTables+nFreeTables=maxTableIndex)
#nTablesInGroup = nByGroup
# nTablesInRestaurant = nByGroup
observationGroupAllocation = rep(1:nGroups, times = nByGroup)
observationDishAllocation          = integer(nObs)
observationDishAllocation[1:200]   = rep(1,100);
observationDishAllocation[201:400] = rep(c(rep(2,30),rep(3,40),rep(1,30)),2)
observationDishAllocation[401:600] = rep(1:100,2)
observationTableAllocation = 1:nObs
groupRestaurantAllocation  = 1:nGroups
observationRestaurantAllocation = groupRestaurantAllocation[observationGroupAllocation]
nGroupsInRestaurant = as.integer(table(groupRestaurantAllocation)) # rep(1,nRest)
nRest = length(table(groupRestaurantAllocation))
maxRestIndex = nRest
tablesValues = observationDishAllocation
tableRestaurantAllocation = observationRestaurantAllocation
nPeopleAtTable = rep(1,nObs)
dishesCounts = as.vector(table(observationDishAllocation)) # how many people are eating a certain dish
nDishes = length(dishesCounts)
set.seed(123)
for (r in 1:nGibbsUpdates) {
### ALLOCATE IN-SAMPLE OBSERVATIONS TO TABLES
if(r%%20==0){print(r)}
indexCustomerGlobal = 1
for (indexGroup in 1:nGroups) {
indexRestaurant = groupRestaurantAllocation[indexGroup]
##### compute quantities without group J
observationRestaurantAllocation_noJ = observationRestaurantAllocation
individualsInCurrentGroup = firstIndividuals[indexGroup]:lastIndividuals[indexGroup]
observationRestaurantAllocation_noJ[individualsInCurrentGroup] = -1
# nPeopleInRestaurant_noJ = sum(observationRestaurantAllocation_noJ==indexRestaurant)
dishesCountsInGroup = as.vector(table(factor(observationDishAllocation[individualsInCurrentGroup],
levels = 1:nDishes))) # number of people eating dish d in group J
dishesCounts_noJ = dishesCounts - dishesCountsInGroup
nDishes_noJ = nDishes - sum(dishesCounts_noJ==0)
##### end computation of quantities without group J
##### initialize quantities for computation of acceptance probability for the "current" state
# nPeopleInRestaurantCS = nPeopleInRestaurant_noJ
dishesCountsCS = dishesCounts_noJ
nDishesCS = nDishes_noJ
##### end initialization quantities for acceptance prob
# define global index to be used in the MH part to start from the right global index
indexCustomerGlobalMH = indexCustomerGlobal
logP_CS = 0 # log of P[X_ji=x|____S] to be used in MH
for (indexCustomerGroup in 1:nByGroup[indexGroup]) {
currentTable = observationTableAllocation[indexCustomerGlobal] # get the current table
currentDish = observationDishAllocation[indexCustomerGlobal] # get the current dish (this definition could be avoided)
nPeopleAtTable[currentTable] = nPeopleAtTable[currentTable] - 1
if(nPeopleAtTable[currentTable] == 0) { # free the table
nFreeTables = nFreeTables + 1
freeTables = c(currentTable,freeTables)
tableRestaurantAllocation[currentTable] = -1
nTables = nTables - 1
tablesValues[currentTable] = -1
}
nTablesInRestaurant = sum(tableRestaurantAllocation==indexRestaurant)
indecesTablesInRestaurant = (1:maxTableIndex)[tableRestaurantAllocation==indexRestaurant] # indeces of tables in the restaurant
indecesPossibleTables = (tablesValues[indecesTablesInRestaurant] == currentDish) # tables in the restaurant serving the current dish
possibleTables = c(indecesTablesInRestaurant[indecesPossibleTables],-1)
probNewTable = (theta + sigma*nTablesInRestaurant)/(nTables + theta0)
nTablesServingCurrentDish = sum(tablesValues == currentDish)
if(nTablesServingCurrentDish > 0) {
probNewTable = probNewTable*(nTablesServingCurrentDish - sigma0)
}
probs = c(nPeopleAtTable[indecesTablesInRestaurant][indecesPossibleTables] - sigma, probNewTable)
newTableAllocation = sample(possibleTables,1,replace = F, prob = probs)
if(newTableAllocation < 0) {
##### COMPUTE THE CONTRIBUTION PART OF THE LOG ACCEPTANCE PROBABILITY
individualsToRemove = c((firstIndividuals[indexGroup]-1+indexCustomerGroup):lastIndividuals[indexGroup])
nPeopleAtTableCS = as.integer(table(factor(observationTableAllocation[-individualsToRemove], levels = 1:maxTableIndex))) # nPeopleAtTable - as.integer(table(factor(observationTableAllocation[individualsToRemove], levels = 1:maxTableIndex))) # as.integer(table(factor(observationTableAllocation_noJ, levels = 1:maxTableIndex))) # this is wrong since it removes twice the current observation from the count of people at table
nTablesCS = sum(nPeopleAtTableCS>0)
# compute nTablesInRestaurantCS
# freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0]
# tableRestaurantAllocationCS = tableRestaurantAllocation
# tableRestaurantAllocationCS[freeTablesCS] = -1
# nTablesInRestaurantCS = sum(tableRestaurantAllocationCS==indexRestaurant)
# nTablesInRestaurantCS =
#   length(table(observationTableAllocation[-individualsToRemove][observationRestaurantAllocation[-individualsToRemove]==indexRestaurant]))
#
# compute log of P[X_ji=x|____]
if(dishesCountsCS[currentDish] == 0){ # X_ji = "new"
logP_CS = logP_CS +
log(theta0 + nDishesCS*sigma0) -
log(theta0 + nTablesCS)
nDishesCS = nDishesCS + 1
} else{
# compute number of tables serving the current dish in the whole franchise, excluding individualsToRemove
# nTablesServingCurrentDishCS = length(table(observationTableAllocation[-individualsToRemove][observationDishAllocation[-individualsToRemove] == currentDish]))
# alternative computation:
freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0] # which(nPeopleAtTableCS == 0)
tablesValuesCS = tablesValues
tablesValuesCS[freeTablesCS] = -1
nTablesServingCurrentDishCS = sum(tablesValuesCS==currentDish)
# get the tables in current restaurant serving the current dish (excluding future observations)
# freeTablesCS = (1:maxTableIndex)[nPeopleAtTableCS == 0] # which(nPeopleAtTableCS == 0)
# tableRestaurantAllocationCS = tableRestaurantAllocation
# tableRestaurantAllocationCS[freeTablesCS] = -1
# tablesInRestaurantServingCurrentDishCS = (1:maxTableIndex)[((tableRestaurantAllocationCS == indexRestaurant)&(tablesValues == currentDish))]
# tablesValuesCS = tablesValues
# tablesValuesCS[freeTablesCS] = -1
#nTablesInRestaurantServingCurrentDishCS = length(tablesInRestaurantServingCurrentDish)
logP_CS = logP_CS +
log(nTablesServingCurrentDishCS - sigma0) -
log(theta0 + nTablesCS)
}
### update quantities of "current state"
# nPeopleInRestaurantCS = nPeopleInRestaurantCS + 1
dishesCountsCS[currentDish] = dishesCountsCS[currentDish] + 1
##### UPDATE GIBBS SAMPLING QUANTITIES
nTables = nTables + 1
if(nFreeTables > 0) { # pick the first free table
newTableAllocation = freeTables[1]
freeTables = freeTables[-1]
nFreeTables = nFreeTables - 1
nPeopleAtTable[newTableAllocation] = 1
tablesValues[newTableAllocation] = currentDish
tableRestaurantAllocation[newTableAllocation] = indexRestaurant # assign table to restaurant
} else { # create a new table
maxTableIndex = maxTableIndex + 1
newTableAllocation = maxTableIndex
nPeopleAtTable = c(nPeopleAtTable,1)
tablesValues = c(tablesValues,currentDish)
tableRestaurantAllocation = c(tableRestaurantAllocation,indexRestaurant) # assign table to restaurant
}
} else{ # the sampled table is already occupied in the restaurant --> just update the relevant quantities
nPeopleAtTable[newTableAllocation] = nPeopleAtTable[newTableAllocation] + 1
}
observationTableAllocation[indexCustomerGlobal] = newTableAllocation
indexCustomerGlobal = indexCustomerGlobal + 1
}
#### MH STEP
# we begin the MH proposal sampling
nRestMH = nRest
maxRestIndexMH = maxRestIndex
groupRestaurantAllocationMH = groupRestaurantAllocation
nGroupsInRestaurantMH = nGroupsInRestaurant
nGroupsInRestaurantMH[indexRestaurant] = nGroupsInRestaurantMH[indexRestaurant] - 1
nFreeRestaurantsMH = nFreeRestaurants
freeRestaurantsMH = freeRestaurants
if(nGroupsInRestaurantMH[indexRestaurant] == 0) {
nRestMH = nRestMH - 1
nFreeRestaurantsMH = nFreeRestaurantsMH + 1
freeRestaurantsMH = c(indexRestaurant,freeRestaurantsMH)
}
#### PROPOSE A NEW RESTAURANT AND TABLE ALLOCATION
#### sample restaurant
nonEmptyRest = (1:maxRestIndexMH)[nGroupsInRestaurantMH>0] # restaurants with at least one group assigned
possibleRestaurants = c(nonEmptyRest,-1)
probs =c(nGroupsInRestaurantMH[nonEmptyRest] - alpha, gamma + alpha*nRestMH)
newRestaurantAllocation = sample(possibleRestaurants,1,replace = F, prob = probs)
if(newRestaurantAllocation < 0) {
nRestMH = nRestMH + 1
if(nFreeRestaurantsMH > 0) { # pick the first free restaurant
newRestaurantAllocation = freeRestaurantsMH[1]
freeRestaurantsMH = freeRestaurantsMH[-1]
nFreeRestaurantsMH = nFreeRestaurantsMH - 1
nGroupsInRestaurantMH[newRestaurantAllocation] = 1
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
} else { # create a new restaurant
maxRestIndexMH = maxRestIndexMH + 1
newRestaurantAllocation = maxRestIndexMH
nGroupsInRestaurantMH = c(nGroupsInRestaurantMH,1)
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
}
} else{ # the sampled restaurants contains already some groups --> just update the relevant quantities
groupRestaurantAllocationMH[indexGroup] = newRestaurantAllocation # assign group to restaurant
nGroupsInRestaurantMH[newRestaurantAllocation] = nGroupsInRestaurantMH[newRestaurantAllocation] + 1
}
#### sample table allocation
# initialize MH quantities excluding current group j
maxTableIndexMH = maxTableIndex
observationTableAllocationMH = observationTableAllocation
observationTableAllocationMH[individualsInCurrentGroup] = -1
observationRestaurantAllocationMH = observationRestaurantAllocation_noJ # computed above
observationDishAllocationMH = observationDishAllocation
observationDishAllocationMH[individualsInCurrentGroup] = -1
nPeopleAtTableMH = as.integer(table(factor(observationTableAllocation[-individualsInCurrentGroup], levels = 1:maxTableIndex))) # nPeopleAtTable - as.integer(table(factor(observationTableAllocation[individualsInCurrentGroup], levels = 1:maxTableIndex))) # as.integer(table(factor(observationTableAllocation_noJ, levels = 1:maxTableIndex)))
nTablesMH = sum(nPeopleAtTableMH>0)
freeTablesMH = (1:maxTableIndexMH)[nPeopleAtTableMH == 0]
nFreeTablesMH = length(freeTablesMH)
tablesValuesMH = tablesValues
tablesValuesMH[freeTablesMH] = -1
tableRestaurantAllocationMH = tableRestaurantAllocation
tableRestaurantAllocationMH[freeTablesMH] = -1
# nPeopleInRestaurantMH = nPeopleInRestaurant_noJ # computed above
dishesCountsMH = dishesCounts_noJ
nDishesMH = nDishes - sum(dishesCountsMH==0)
# # nTablesServingCurrentDish = sum(tablesValues_noJ == observationDishAllocation[indexCustomerGlobal])
##### end computation of quantities without group J
# #### UPDATE TABLE CONFIGURATION IN THE CURRENT GROUP (analogous to the sampling from the full conditionals)
logP_MH = 0 # log of P[X_ji=x|____ S'] to be used in MH
for (indexCustomerGroup in 1:nByGroup[indexGroup]) { # this loop should be joined with the loop for the full conditionals!!!!!
indecesTablesInRestaurant = (1:maxTableIndexMH)[tableRestaurantAllocationMH==newRestaurantAllocation]
currentDish = observationDishAllocation[indexCustomerGlobalMH] # get the current dish
observationRestaurantAllocationMH[indexCustomerGlobalMH] = newRestaurantAllocation
nTablesInRestaurant = sum(tableRestaurantAllocationMH==newRestaurantAllocation)
indecesPossibleTables = (tablesValuesMH[indecesTablesInRestaurant] == observationDishAllocation[indexCustomerGlobalMH])
possibleTables = c(indecesTablesInRestaurant[indecesPossibleTables],-1)
probNewTable = (theta + sigma*nTablesInRestaurant)/(nTablesMH + theta0)
nTablesServingCurrentDishMH = sum(tablesValuesMH == observationDishAllocation[indexCustomerGlobalMH])
if(nTablesServingCurrentDishMH > 0) {
probNewTable = probNewTable*(nTablesServingCurrentDishMH - sigma0)
}
probs = c(nPeopleAtTableMH[indecesTablesInRestaurant][indecesPossibleTables] - sigma, probNewTable)
newTableAllocation = sample(possibleTables,1,replace = F, prob = probs)
if(newTableAllocation < 0) {
# compute log of P[X_ji=x|____S']
if(dishesCountsMH[currentDish] == 0){ # X_ji = "new"
logP_MH = logP_MH +
log(theta0 + nDishesMH*sigma0) -
log(theta0 + nTablesMH)
} else{
# compute number of tables serving the current dish in the whole franchise, excluding future individuals
nTablesServingCurrentDishMH = length(table(observationTableAllocationMH[observationDishAllocationMH == currentDish]))
# get the tables in current restaurant serving the current dish (excluding future observations)
# tablesInRestaurantServingCurrentDish = (1:maxTableIndexMH)[((tableRestaurantAllocationMH == newRestaurantAllocation)&(tablesValuesMH == currentDish))]
logP_MH = logP_MH +
log(nTablesServingCurrentDishMH - sigma0) -
log(theta0 + nTablesMH)
}
### update quantities of MH
# nPeopleInRestaurantMH = nPeopleInRestaurantMH + 1
dishesCountsMH[currentDish] = dishesCountsMH[currentDish] + 1
observationDishAllocationMH[indexCustomerGlobalMH] = currentDish
nTablesMH = nTablesMH + 1
if(nFreeTablesMH > 0) { # pick the first free table
newTableAllocation = freeTablesMH[1]
freeTablesMH = freeTablesMH[-1]
nFreeTablesMH = nFreeTablesMH - 1
nPeopleAtTableMH[newTableAllocation] = 1
tablesValuesMH[newTableAllocation] = observationDishAllocationMH[indexCustomerGlobalMH]
tableRestaurantAllocationMH[newTableAllocation] = newRestaurantAllocation # assign table to restaurant
} else { # create a new table
maxTableIndexMH = maxTableIndexMH + 1
newTableAllocationMH = maxTableIndexMH
nPeopleAtTableMH = c(nPeopleAtTableMH,1)
tablesValuesMH = c(tablesValuesMH,observationDishAllocationMH[indexCustomerGlobalMH])
tableRestaurantAllocationMH = c(tableRestaurantAllocationMH,newRestaurantAllocation) # assign table to restaurant
}
} else{ # the sampled table is already occupied in the restaurant --> just update the relevant quantities
nPeopleAtTableMH[newTableAllocation] = nPeopleAtTableMH[newTableAllocation] + 1
}
observationTableAllocationMH[indexCustomerGlobalMH] = newTableAllocation
# update indexCustomerGlobalMH
indexCustomerGlobalMH = indexCustomerGlobalMH + 1
}
pAccept = min(exp(logP_MH - logP_CS),1)
accept = runif(1) < pAccept
# print(pAccept)
if(accept == T){
nRest = nRestMH
maxRestIndex = maxRestIndexMH
groupRestaurantAllocation[indexGroup] = groupRestaurantAllocationMH[indexGroup]
nGroupsInRestaurant = nGroupsInRestaurantMH
nFreeRestaurants = nFreeRestaurantsMH
freeRestaurants = freeRestaurantsMH
maxTableIndex = maxTableIndexMH
observationTableAllocation = observationTableAllocationMH
observationRestaurantAllocation = observationRestaurantAllocationMH
nPeopleAtTable = nPeopleAtTableMH
nTables = nTablesMH
freeTables = freeTablesMH
nFreeTables = nFreeTablesMH
tablesValues = tablesValuesMH
tableRestaurantAllocation = tableRestaurantAllocationMH
}
##### END OF METROPOLIS HASTINGS STEP
### EDIT THIS PART TO UPDATE THE TABLES ALLOCATIONS FOR THE WHOLE GROUP
groupRestaurantAllocationAcrossGibbs[r, indexGroup] = groupRestaurantAllocation[indexGroup]
observationTableAllocationAcrossGibbs[r,firstIndividuals[indexGroup]:lastIndividuals[indexGroup]] =
observationTableAllocation[firstIndividuals[indexGroup]:lastIndividuals[indexGroup]]
}
### SAMPLE TABLE AND DISH FOR OUT-OF-SAMPLE OBSERVATIONS
# THIS HAS BEEN MOVED OUT OF THE LOOP FOR THE MOMENT
}
nTablesServingCurrentDish
sigma0
log(nTablesServingCurrentDishCS - sigma0)
nTablesServingCurrentDishCS
g=0.1; p=0.9; (1+g)/p + (1-p)/p
g=0.001; p=0.999; (1+g)/p + (1-p)/p
60/16
60/76
10/11
10000/(40*60)
unlink("Library/CloudStorage/Dropbox/Teaching/UNITO/ISL/Rebaudo/Rebaudo - 2023:24/Lect 13-14 Cross Validation and Resampling upload/Chp 5 - Validation and Resampling_cache", recursive = TRUE)
library(ISLR2)
# Lab: Cross-Validation and the Bootstrap
library(ISLR2)
?library
set.seed(1)
?Auto
train <- sample(392,196)
train
lm.fit <- lm(mpg~horsepower, data=Auto, subset = train)
lm.fit
summary(lm.fit)
attach(Auto)
mpg
mean( (mpg-predict(lm.fit, Auto))[-train]^2 )
plot(mpg~horsepower)
lm.fit2 <- lm(mpg~poly(horsepower,2), data=Auto, subset = train)
mean( (mpg-predict(lm.fit2, Auto))[-train]^2 )
lm.fit3 <- lm(mpg~poly(horsepower,3), data=Auto, subset = train)
mean( (mpg-predict(lm.fit3, Auto))[-train]^2 )
set.seed(2)
train <- sample(392,196)
set.seed(2)
train <- sample(392,196)
lm.fit <- lm(mpg~horsepower, data=Auto, subset = train)
mean( (mpg-predict(lm.fit, Auto))[-train]^2 )
lm.fit2 <- lm(mpg~poly(horsepower,2), data=Auto, subset = train)
mean( (mpg-predict(lm.fit2, Auto))[-train]^2 )
lm.fit3 <- lm(mpg~poly(horsepower,3), data=Auto, subset = train)
mean( (mpg-predict(lm.fit3, Auto))[-train]^2 )
glm.fit(mpg~horsepower, data=Auto)
glm.fit(mpg~horsepower)
glm.fit <- glm(mpg~horsepower, data=Auto)
coef(glm.fit)
glm.fit <- glm(mpg~horsepower, data=Auto)
coef(glm.fit)
lm.fit <- lm(mpg~horsepower, data=Auto)
coef(lm.fit)
library(boot)
library(boot)
cv.err <- cv.glm(Auto, glm.fit)
cv.err
cv.err$delta
cv.error <- double(10)
cv.error
cv.error <- double(10)
for (i in 1:10){
glm.fit <- glm(mpg~poly(horsepower, i), data=Auto)
cv.error[i] <- cv.glm(Auto, glm.fit)$delta[1]
}
cv.error
plot(cv.error,type="b")
loocv <- function(fit){
h <- lm.influence(fit)$h
mean((residual(fit)/(1-h))^2)
}
set.seed(17)
set.seed(17)
cv.error.10 <- rep(0, 10)
cv.error.10
set.seed(17)
cv.error.10 <- rep(0, 10)
for (i in 1:10){
glm.fit <- glm(mpg~poly(horsepower, i), data=Auto)
cv.error[i] <- cv.glm(Auto, glm.fit, K=10)$delta[1]
}
set.seed(17)
cv.error.10 <- rep(0, 10)
for (i in 1:10){
glm.fit <- glm(mpg~poly(horsepower, i), data=Auto)
cv.error.10[i] <- cv.glm(Auto, glm.fit, K=10)$delta[1]
}
cv.error.10
lines(cv.error.10, type="b", col=2)
i
i=1
glm.fit <- glm(mpg~poly(horsepower, i), data=Auto)
cv.glm(Auto, glm.fit, K=10)$delta
cv.glm(Auto, glm.fit)$delta
alpha.fn <- function(data, index){
X <- data$X[index]
Y <- data$Y[index]
(var(Y)-cov(X,Y))/(Var(X)+Var(Y)-2*cov(X,Y))
}
alpha.fn(Portfolio,1:100)
alpha.fn <- function(data, index){
X <- data$X[index]
Y <- data$Y[index]
(var(Y)-cov(X,Y))/(var(X)+var(Y)-2*cov(X,Y))
}
alpha.fn(Portfolio,1:100)
alpha.fn(Portfolio, sample(100, 100, replace=T))
boot(Portfolio, alpha.fn, R=1000)
alpha.fn(Portfolio,1:100)
boot.fn <- function(data, index){}
boot.fn <- function(data, index){
coef(lm(mpg~horsepower, data=data, subset=index))
}
boot.fn(Auto, 1:392)
set.seed(1)
boot.fn(Auto, sample(392, 392, replace=T))
boot(Auto, boot.fn, 1000)
summary(lm(mpg~horsepower, data=Auto))$coef
94/4
23.5/4
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.15
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(dplyr)
library(tidyr)
library(mvtnorm)
library(invgamma)
library(splines)
library(ggplot2)
theme_set(theme_bw(base_size = 14))
library(reshape2)
set.seed(1992)
source("SEP_fcts.R")
## global variables for the dta
out = readDta_reg(file="Data-and-Results/data_protein.RData")
## make global vars for the data
X = out$X
y = out$y
my = mean(y,na.rm=T)
sy =  mean(apply(y,2,var,na.rm=T))
ages = out$ages ## age grid (for plotting)
C=out$C
R=out$R
p=out$p
## prior pars
prior = list(
## column effects (proteins)
meta = rep(0,p),
Seta = diag(p),  ## might want to reduce var of trt offsets (2nd part)
aeta = 1,        ## eta[j] ~ G_eta; G_eta ~ PY(aeta, N(meta,Seta))
beta = 0.05, #- discount parameter
## row effects (patients)
mxi = my, ## xi[i] ~ G_xi; G_xi ~ PY(axi, N(mxi,Sxi))
Sxi = 25, # large to favor assignment of common effect to patients instead of protein
axi = 0.1,
bxi = -0.1, # # 0 as a DP
## hyperpars theta=sig2
asig = 2,
bsig = 2) ## w=1/sigs ~ Ga(asig/2, bsig/2); E(w) = m=a/b, V(w)=m/(b/2)
# Run MCMC
if (FALSE){
main_reg(6000)
}
startTime = Sys.time()
main_reg(6000)
timeRPM = difftime(Sys.time(), startTime, units=("secs"))[[1]]
maxDiff_reg
timeREG = difftime(Sys.time(), startTime, units=("secs"))[[1]]
timeRPM
timeRPM/60
pltInit_reg()
load("Data-and-Results/yt.RData")
of = maxDiff_reg()
P1 = plt_reg_ggplot(T,T,F,1,case=T,ctr=T)
P2 = plt_reg_ggplot(T,T,F,1001,case=T,ctr=T)
library(cowplot)
P1 = P1 + theme(axis.title = element_blank())
P2 = P2 + theme(axis.title = element_blank())
P  = plot_grid(P1, P2)
# Individual plot
P  = P +
draw_label("ages", x= 0.52, y=  0, vjust=-0.5, angle= 0) +
draw_label("Y",    x=  0, y=0.55, vjust= 1.5, angle=90)
P
######### Normal- QQtest #####################
chain = mcmc[,-1]
colnames(chain) = c("it", "SSM", "sig2", "K-prot", "K-pat", paste("nk",1:5,sep=""), paste("nk",1:5,sep=""))
chain$`K-pat`
length(chain$`K-pat`)
6000/50
6000/10
pltInit_reg()
load("Data-and-Results/yt.RData")
of = maxDiff_reg()
maxDiff_reg
Eyp0
dim(Eyp0)
