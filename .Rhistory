rxg=1
for(tt in cc){
for(mm in 1:dim(y)[1]){
if(!is.na(y[mm,tt])){
xg[rxg,]=x[mm,]
rxg=rxg+1
}
}
}
sigma_n_inv=rep(1/sigma2_h[g],length(yg))
sigtemp= solve(solve(betasig0)+ t(xg) %*% (sigma_n_inv * xg))
sigtemp= makeSymm(sigtemp)
#beta prior mean 0, don't write out
meantemp= sigtemp %*% (t(xg) %*% (sigma_n_inv * yg))
beta[g,]=rmvnorm(1,mean=meantemp,sigma = sigtemp)
sigma2_h[g]=rinvgamma(1,1+ns[g]*dim(y)[1]/2,1+sum((yg-xg %*% beta[g,])^2)/2)
# gamma calculation
gamma_store[iter,which(s==g)]=x[32,7:12] %*% meantemp[7:12]-x[17,7:12] %*% meantemp[7:12]
}
}
beta_store[[iter]]=beta
sigma2h_store[[iter]]=sigma2_h
#update alpha_p
for(j in 1:n){
yj=y[!is.na(y[,j]),j]
nj=length(yj)
xj=x[!is.na(y[,j]),]
dj=delta_expand[!is.na(y[,j])]
alphap[j]=rnorm(1,(sum(yj-xj %*% beta[s[j],]-dj)/sigma2_h[s[j]])/(1/1+dim(y)[1]/sigma2_h[s[j]]),sqrt(1/(1/1+dim(y)[1]/sigma2_h[s[j]])))
}
alphap_store[[iter]]=alphap
#update delta
for(t in 1:length(age_unq)){
ti=which(age_match==t)
yi_d=list()
idx=list()
sigs=list()
ni= rep(0,length(ti))
for(tt in 1:length(ti)){
i=ti[tt]
yi_vec=y[i,]-alphap- x[i,] %*% t(beta[s,])
yi_d[[tt]]=yi_vec[!is.na(yi_vec)]
idx[[tt]]=!is.na(yi_vec)
ni[tt]=length(yi_d[[tt]])
s2=s[!is.na(y[i,])]
sigs[[tt]]=sigma2_h[s2]
}
yi_d=unlist(yi_d)
sigs=unlist(sigs)
delta[t]=rnorm(1,sum(yi_d/sigs)/(1/deltasig0^2+sum(1/sigs)),sqrt(1/(1/deltasig0+sum(1/sigs))))
}
delta_store[[iter]]=delta
#expand delta as it was for unique ages -- expand it to all y
delta_expand=rep(0,dim(y)[1])
for(i in 1:dim(y)[1]){
delta_expand[i]=delta[age_match[i]]
}
# update pi
V=c(sapply(1:(N-1),function(i) rbeta(1,1+ns[i],alpha+sum(ns[(i+1):N]))),1)
pi=c(V[1],sapply(2:N,function(i) V[i]*prod(1-V[1:(i-1)])))
pi_store[[iter]]=pi
## chi2-test if one wishes to do
# xch[iter]=rchisq(1,bin-1)
# nn=length(y)
# z=matrix(0,nn,bin)
# tt=1
# #cl=as.numeric(names(table(s)))
# #xdelta=sapply(1:dim(y)[1], function(mm) x[mm,] %*% delta_expand[mm,])
# for(j in 1:n){
#   yj=y[,j]-alphap[j]-delta_expand
#   yj=yj[!is.na(yj)]
#   nj=length(yj)
#   p=exp(ll[j,])
#   p=p/sum(p)
#   mj= rowSums(sapply(1:dim(beta)[1], function(gg) p[gg]*x %*% beta[gg,])) #xx %*% beta[s[j],]
#   stdj=sqrt(sum(p^2*sigma2_h))
#   #mj=xx %*% beta[s[j],]
#   #stdj=sqrt(sigma2_h[s[j]])
#   for(ii in 1:nj){
#     yqt= qnorm(binqt,mj[ii],stdj)
#     z[tt,zij(yj[ii],yqt)]=1
#     tt=tt+1
#   }
# }
#
# mk=colSums(z)
# R[iter]=sum(((mk-nn*1/bin)/sqrt(nn*1/bin))^2)
#
####### for normal QQ test #######
zip_i=sample(1:dim(y)[1],1)
zip_p=sample(1:n,1)
mip=alphap[zip_p]+x[zip_i,] %*% beta[s[zip_p],]+delta_expand[zip_i]
zip[iter]=(y[zip_i,zip_p]-mip)/sqrt(sigma2_h[s[zip_p]])
print(iter)
}
zzip=zip[seq(0.5*tot_iter,tot_iter,5)]
zzip=zzip[!is.na(zzip)]
plot(ll_store[1000:5000],type="l")
for(tt in 1:TT){
ii=idx2[tt]
s_temp=s_store[[ii]]
cl_temp=unique(s_temp)
s_mat_temp=matrix(0,n,n)
for(ss in cl_temp){
s_mat_temp[which(s_temp==ss),which(s_temp==ss)]=1
}
svec=s_mat_temp[lower.tri(s_mat_temp,diag = F)]
one_pos[[tt]]=which(svec==1)
print(tt)
}
hem_dist=rep(0, TT)
hem_dist_mat=matrix(0,TT,TT)
for(ii in 1:TT){
for(jj in ii:TT){
print(c(ii,jj))
s1=rep(0,n*(n-1)/2)
s2=rep(0,n*(n-1)/2)
s1[one_pos[[ii]]]=1
s2[one_pos[[jj]]]=1
hem_dist_mat[ii,jj]=sum(s1!=s2)*2
}
}
hem_dist_mat2=t(hem_dist_mat)+hem_dist_mat
hem_dist = rowMeans(hem_dist_mat2)
which.min(hem_dist)
#######################################
# resample variables based on cluster number result from above
idx_star=idx2[which.min(hem_dist)]
s_star=s_store[[idx_star]]
nc=length(unique(s_star))
tb=table(s_star)
ns=as.vector(tb)
cl_star= as.numeric(names(tb))
TT=1000
alpha_star=alphap_store[[idx_star]]
sigma2h_star=sigma2h_store[[idx_star]][cl_star]
beta_star_post=array(0,dim=c(TT,nc,dim(x)[2]))
beta_star_post[1,,]=beta_store[[idx_star]][cl_star]
sigma2h_star_post=matrix(0,TT,nc)
sigma2h_star_post[1,]=sigma2h_star
alpha_star_post=matrix(0,TT,n)
alpha_star_post[1,]=alpha_star
delta_star_post=matrix(0,TT,length(age_unq))
delta_star_post[1,]=delta_store[[idx_star]]
delta_star_post_expand=matrix(0,TT,dim(y)[1])
for(i in 1:dim(y)[1]){
delta_star_post_expand[1,i]=delta_star_post[1,age_match[i]]
}
for(qq in 1:(TT-1)){
for(g in 1:nc){
yg=as.vector(y[,which(s_star==cl_star[g])]-alpha_star_post[qq,which(s_star==cl_star[g])]-delta_star_post_expand[qq,])
yg=yg[!is.na(yg)]
xg=matrix(0,length(yg),dim(x)[2])
cc=which(s_star==cl_star[g])
rxg=1
for(tt in cc){
for(mm in 1:dim(y)[1]){
if(!is.na(y[mm,tt])){
xg[rxg,]=x[mm,]
rxg=rxg+1
}
}
}
sigma_n_inv=rep(1/sigma2h_star_post[qq,g],length(yg))
sigtemp= solve(solve(betasig0)+ t(xg) %*% (sigma_n_inv * xg))
sigtemp= makeSymm(sigtemp)
meantemp= sigtemp %*% (t(xg) %*% (sigma_n_inv * yg))
beta_star_post[qq+1,g,]=rmvnorm(1,mean=meantemp,sigma = sigtemp)
sigma2h_star_post[qq+1,g]=rinvgamma(1,1+length(yg)/2,1+sum((yg-xg %*% beta_star_post[qq+1,g,])^2)/2)
}
for(j in 1:n){
sj=which(cl_star==s_star[j])
yj=y[!is.na(y[,j]),j]
nj=length(yj)
xj=x[!is.na(y[,j]),]
dj=delta_star_post_expand[qq,!is.na(y[,j])]
alpha_star_post[qq+1,j]=rnorm(1,(5/5+sum(yj-xj %*% beta_star_post[qq+1,sj,] -dj)/sigma2h_star_post[qq+1,sj])/(1/5+nj/sigma2h_star_post[qq+1,sj]),sqrt(1/(1/5+nj/sigma2h_star_post[qq+1,sj])))
}
sjs=sapply(1:n, function(j) which(cl_star==s_star[j]))
for(t in 1:length(age_unq)){
ti=which(age_match==t)
yi_d=list()
idx=list()
sigs=list()
ni= rep(0,length(ti))
for(tt in 1:length(ti)){
i=ti[tt]
yi_vec=y[i,]-alpha_star_post[qq+1,]- x[i,] %*% t(beta_star_post[qq+1,sjs,])
yi_d[[tt]]=yi_vec[!is.na(yi_vec)]
idx[[tt]]=!is.na(yi_vec)
ni[tt]=length(yi_d[[tt]])
s2=sjs[!is.na(y[i,])]
sigs[[tt]]=sigma2h_star_post[qq+1,s2]
}
yi_d=unlist(yi_d)
sigs=unlist(sigs)
delta_star_post[qq+1,t]=rnorm(1,sum(yi_d/sigs)/(1/deltasig0^2+sum(1/sigs)),sqrt(1/(1/deltasig0^2+sum(1/sigs))))
}
for(i in 1:dim(y)[1]){
delta_star_post_expand[qq+1,i]=delta_star_post[qq+1,age_match[i]]
}
print(qq)
}
beta_star_post_mean=apply(beta_star_post,c(2,3),mean)
alpha_star_post_mean=colMeans(alpha_star_post)
sigma2h_star_post_mean=colMeans(sigma2h_star_post)
delta_star_post_mean=colMeans(delta_star_post)
delta_star_post_expand_mean=colMeans(delta_star_post_expand)
##### calculate R^2 in each cluster
R_sq=rep(0,nc)
muc=matrix(0,nc,32)
for(i in 1:nc){
muc[i,]=x %*% beta_star_post_mean[i,]
}
xdelta=sapply(1:32, function(i) delta_star_post_expand_mean[i])
for(ii in 1:length(cl_star)){
idx_cl=which(s_star==cl_star[ii])
yhat=matrix(0,32,length(idx_cl))
for(i in 1:length(idx_cl)){
yhat[,i]=x %*% beta_star_post_mean[ii,] + xdelta + rep(alpha_star_post_mean[idx_cl[i]],dim(x)[1])
}
ssr_cl=sum((y[,idx_cl]- yhat)^2,na.rm = T)
sst_cl=sum((y[,idx_cl]- mean(y[,idx_cl],na.rm=T))^2,na.rm=T)
R_sq[ii]=1-ssr_cl/sst_cl
}
R_sq
#### calculate mu and ymean in each cluster
muc=matrix(0,nc,32)
for(i in 1:nc){
muc[i,]=x %*% beta_star_post_mean[i,]
}
a_mat=matrix(0,32,n)
for(i in 1:n){
a_mat[,i]=alpha_star_post_mean[i]
}
ymean0=matrix(0,32,nc)
for(i in 1:nc){
pts=which(s_star==cl_star[i])
if(length(pts)>1){
ymean0[,i]=rowMeans(y[,pts],na.rm = T)
}else{
ymean0[,i]=y[,pts]
}
}
muc0=matrix(0,nc,32)
for(i in 1:nc){
pts=which(s_star==cl_star[i])
muc0[i,]=x %*% beta_star_post_mean[i,] + xdelta  +mean(alpha_star_post_mean[pts])
}
###### plotting
col_list=c(1:8,'orange','purple','dark green','maroon','dark blue','dark gray','brown')
name_list=c("(a)","(b)","(c)","(d)","(e)","(f)","(g)","(h)","(i)","(j)","(k)","(l)")
pdf("fit-splines-nosplit-moreb-deltai-t-scalar-5000-2.pdf",width = 9,height = 12)
par(mfrow=c(4,3))
for(i in 1:nc){
plot(PL2[1:16,2],muc0[i,1:16],type='l',col=col_list[i],ylim=c(-4,8),xlab='Age',ylab='(log) Expected Protein Abundance',main=substitute(paste(nn,' ',R^2,'=',mm), list(nn=name_list[i],mm=round(R_sq[i],3))),cex.main= 1)
lines(PL2[17:32,2],muc0[i,17:32],lty=2,col=col_list[i])
lines(PL2[1:16,2],ymean0[1:16,i],col=col_list[i],lty=3)
lines(PL2[17:32,2],ymean0[17:32,i],col=col_list[i],lty=4)
legend("topright", lty=c(1,2,3,4),legend=c("patient(fit)","control(fit)","patient(obs)","control(obs)"),col=col_list[i],bty = 'n',cex=0.8)
}
dev.off()
par(mfrow=c(1,1))
nc_order=c(11,1,3,4,5,6,7,10,9,8,2)
pdf("fit-splines-nosplit-moreb-deltai-t-scalar-5000-2-adjod-pcflip-2.pdf",width = 7.5,height = 10)
par(mfrow=c(4,3))
for(ii in 1:nc){
i=nc_order[ii]
plot(PL2[17:32,2],muc0[i,17:32],type='l',col=col_list[ii],ylim=c(-4,8),xlab='Age',ylab='(log) Expected Protein Abundance',main=substitute(paste(nn,' ',R^2,'=',mm), list(nn=name_list[ii],mm=round(R_sq[i],3))),cex.main= 1)
lines(PL2[1:16,2],muc0[i,1:16],lty=2,col=col_list[ii])
lines(PL2[17:32,2],ymean0[17:32,i],col=col_list[ii],lty=3)
lines(PL2[1:16,2],ymean0[1:16,i],col=col_list[ii],lty=4)
legend("topright", lty=c(1,2,3,4),legend=c("patient(fit)","control(fit)","patient(obs)","control(obs)"),col=col_list[ii],bty = 'n',cex=0.8)
}
dev.off()
par(mfrow=c(1,1))
yhat
######### Normal- QQtest #####################
yhat=matrix(0,dim(y)[1],n)
zip=matrix(0,dim(y)[1],n)
cl_star
s_star
Ey
Eyp
# Codes accompanying "Separate Exchangeability as
# Modeling Principle in Bayesian Nonparametrics"
# Load relevant libraries, functions and data ----------------------------------
rm(list=ls())
# Set the working directory to the current folder
# Code to set the working directory to the current folder from RStudio
library(rstudioapi) # version 0.15
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
library(dplyr)
library(tidyr)
library(mvtnorm)
library(invgamma)
library(splines)
library(ggplot2)
theme_set(theme_bw(base_size = 14))
library(reshape2)
# Data:
#   is read in by readDta(), which is called right after it's defined.
# Data comes from the file  "data_protein.RData"
# After calling readDta() the design matrix and responses are saved
# in global variables "X, y"
# and C (=# columns=proteins), R (=# rows, i.e., patients)
# and p (dim of design vector).
# That is X is (R x p) etc.
#
#
# Prior:
# prior par's are set in a global variable "prior = list(..)"
# which is set right after reading in the data.
# In particular (m-eta, S-eta) are the normal moments of protein-specific
# spline coefficients eta_j; (m-xi, S-xi) the same for patient-specific xi_i.
# (a-eta, b-eta) are the PY par's for proteins;
# and (a-xi, b-xi) the same for patients.
#
#
# main:
# first sets up data structures for G_eta ~ PY(a,b) and G_xi ~ PY(a,b).
# Since we have y[ijt] ~ N(xi_i + x_i' eta_j, sig^2)
# we introduce an adjusted outcome
# yt = y-xi with mdpOffset(mdpXi) before updating eta's, and similarly
# yt = y-eta with mdpOffset(mdpEta) before updating xi's.
# The yt is a global variable.
# mdpInitClust(.) simply initializes the random partition of the eta_j's
# THe main MCMC is then
# for(it in 1:niter){
#   update eta
#   update xi
#   update sig^2
# }
#
#
# sim results:
# are saved in mcmcUpd().
# All it does is just update running totals Ey (for fitted curves),
# Eyp (for fitted curves *w/o* patient effects -- just proteins).
# Those are saved in "Ey.txt", "Ey2.txt"(for 2nd moments) etc.
#
#
# random partition:
# mdp$s are random partition cluster membership indicators
# (mdp=mdpEta, and mdp=mdpXi for proteins and patients, respectively).
# Those are saved in "sProt.txt" (just the first 250 proteins..),
# and "sPat.txt", respectively.
#
#
# Polya urn:
# see mdpUpdS(.) for the Polya urn for the PY processes.
# For clusters with cardinality < ns (=20)
# I marginalize wrt cluster specific parameters.
# That's a bit computation intensive (using candidate's formula).
# For ns>20 i condition on cluster-specific pars.
# Posterior uncertainty is  small it doesn't make a differcence for our data.
# It's a bit of a pain to keep track of marginal (or conditional, for ns>20)
# cluster-specific likelihood under alternative cluster assignments.
# To be checked further. Seems ok, also since the fitted curves seem ok.
#
#
# plots:
# in the end you find some plotting routines. First call "pltInit(.)",
# just to read in all the sim output from the files into global variables
# (so we don't have to read in for each plot).
# plt_reg(.) is an omnibus plotting funciton.
# Setting the arguments as desired you get whichever plots.
# See "paper_reg(.)" for what we did. Just ignore the "ps_reg(..)" funcitons.
# That's my personal ones to get the right graphics par's
# maxDiff_reg() find the proteins with largest difference across time.
source("SEP_fcts.R")
## global variables for the dta
out = readDta_reg(file="Data-and-Results/data_protein.RData")
## make global vars for the data
X = out$X
y = out$y
my = mean(y,na.rm=T)
sy =  mean(apply(y,2,var,na.rm=T))
ages = out$ages ## age grid (for plotting)
## boxplot(apply(y,2,mean,na.rm=T))
## boxplot(sqrt(apply(y,2,var,na.rm=T)))
C=out$C
R=out$R
p=out$p
## R= # patients (=# time points x2); C=  #proteins
## prior pars
prior = list(
## column effects (proteins)
meta = rep(0,p),
Seta = diag(p),  ## might want to reduce var of trt offsets (2nd part)
aeta = 1,        ## eta[j] ~ G_eta; G_eta ~ PY(aeta, N(meta,Seta))
beta = 0.05,
## row effects (patients)
mxi = my,       ## xi[i] ~ G_xi; G_xi ~ PY(axi, N(mxi,Sxi))
Sxi = 1,
axi = 1,
bxi = 0.05,
## hyperpars theta=sig2
asig = 1,
bsig = 5) ## w=1/sigs ~ Ga(asig/2, bsig/2); E(w) = m=a/b, V(w)=m/(b/2)
#######################################################
## DP mix of normal linear regressions
## use list with
## global vars for data:
## y:  (RxC) R=# patients, C=# proteins
## offset:  (R x C)
## yt: (RxC) copy of y, for (y-offset)
## X:  (Rxp)
##
## parameters:
## d:       dimension: d=1 for patients (="rows"); d=2 for proteins (=cols)
## M:       # experimental units (under d=1: R; under d=2: C)
## q:       dimension of cluster-specific pars (1 under d=1; p under d=2)
## a,b:     hyperpar's for PY (b=0 for DP)
## mbeta,Sbeta:   (qx1) and (qxq) mv or univ normal prior moments for etas[k]
## sigs:    residual variance
##
## local variables
## s:       (Mx1) cluster membership indicators
## K:       # clusters
## betas:   (q x K) cluster specific pars (columns= cluster)
## global variables (for debugging and summaries):
## MSS:     mean residual
## Ey
## Ey2
## nupd
# Run MCMC
if (FALSE){
main_reg(6000)
}
# Plots in the paper
pltInit_reg()
load("Data-and-Results/yt.RData")
of = maxDiff_reg()
P1    = plt_reg_ggplot(T,T,F,1,case=T,ctr=T)
P201  = plt_reg_ggplot(T,T,F,201,case=T,ctr=T)
P1201 = plt_reg_ggplot(T,T,F,1201,case=T,ctr=T)
P2201 = plt_reg_ggplot(T,T,F,2201,case=T,ctr=T)
library(cowplot)
P1    = P1    + theme(axis.title = element_blank())
P201  = P201  + theme(axis.title = element_blank())
P1201 = P1201 + theme(axis.title = element_blank())
P2201 = P2201 + theme(axis.title = element_blank())
P  = plot_grid(P1, P201, P1201, P2201)
# Individual plot
P  = P +
draw_label("ages", x= 0.52, y=  0, vjust=-0.5, angle= 0) +
draw_label("Y", x=  0, y=0.55, vjust= 1.5, angle=90)
P
######### Normal- QQtest #####################
yhat=matrix(0,dim(y)[1],n)
zip=matrix(0,dim(y)[1],n)
for(i in 1:dim(y)[1]){
for(p in 1:n){
c=which(cl_star==s_star[p])
yhat[i,p]=alpha_star_post[1,p]+ x[i,]%*%beta_star_post[1,c,]+delta_star_post_expand[1,i]
zip[i,p]=(y[i,p]-yhat[i,p])/sigma2h_star_post[1,c]
}
}
zip=as.vector(zip[!is.na(zip)])
NN=length(zip)
qqnorm(zip, pch = 1, frame = FALSE,ylim = c(-4,4),xlim=c(-4,4))
lines(seq(-4,4,0.1),seq(-4,4,0.1))
qqline(zip, col = "steelblue", lwd = 2)
######### Normal- QQtest #####################
yhat=matrix(0,dim(y)[1],n)
zip=matrix(0,dim(y)[1],n)
for(i in 1:dim(y)[1]){
for(p in 1:n){
c=which(cl_star==s_star[p])
yhat[i,p]=alpha_star_post[1,p]+ x[i,]%*%beta_star_post[1,c,]+delta_star_post_expand[1,i]
zip[i,p]=(y[i,p]-yhat[i,p])/sigma2h_star_post[1,c]
}
}
alpha_star_post
######### Normal- QQtest #####################
yhat=matrix(0,dim(y)[1],n)
zip=matrix(0,dim(y)[1],n)
cl_star
n
dim(y)[1]
dim(y
dim(y)
dim(y)
######### Normal- QQtest #####################
yhat = matrix(0,dim(y)[1], dim(y)[2])
zip  = matrix(0,dim(y)[1],  dim(y)[2])
s_star
mdpEta
mdpOffset_reg(y,incr=T)
y
offset = 0*y         # initialize matrix of right size
offset = 0*y         # initialize matrix of right size
mdp
hist(yt)
qqnorm(yt, pch = 1, frame = FALSE,ylim = c(-4,4),xlim=c(-4,4))
lines(seq(-4,4,0.1),seq(-4,4,0.1))
######### Normal- QQtest #####################
colnames(mcmc) = c("it", "SSM", "sig2", "K-pat", "K-prot", paste("nk",1:5,sep=""), paste("nk",1:5,sep=""))
mcmc
summary(mcmc)
######### Normal- QQtest #####################
colnames(mcmc) = c("it", "SSM", "sig2", "K-pat", "K-prot", paste("nk",1:5,sep=""), paste("nk",1:5,sep=""))
mcmc
as.factor(MCMC$it)
as.factor(mcmc$it)
######### Normal- QQtest #####################
chain = mcmc[,-1]
colnames(chain) = c("it", "SSM", "sig2", "K-pat", "K-prot", paste("nk",1:5,sep=""), paste("nk",1:5,sep=""))
chain
hist(chain$`K-pat`)
summary(chain$`K-pat`)
